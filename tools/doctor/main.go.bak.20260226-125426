//go:build ignore
// +build ignore

package main

import (
"bytes"
"fmt"
"os"
"path/filepath"
"regexp"
)

func must(err error) {
if err != nil {
panic(err)
}
}

func read(p string) []byte {
b, err := os.ReadFile(p)
must(err)
return b
}

func write(p string, b []byte) {
must(os.MkdirAll(filepath.Dir(p), 0755))
must(os.WriteFile(p, b, 0644))
fmt.Println("Wrote", p)
}

func main() {
// 1) Fix cmd/scan/main.go by removing obvious injected backslash garbage lines.
scanPath := filepath.FromSlash("cmd/scan/main.go")
scan := read(scanPath)

// If file contains lots of standalone backslashes, it's corrupted.
// Remove lines that are just "\" or start with "\t\" patterns from failed injections.
lines := bytes.Split(scan, []byte{'\n'})
var out [][]byte
backslashLine := regexp.MustCompile(^\s*\\+\s*$)
for _, ln := range lines {
if backslashLine.Match(ln) {
continue
}
out = append(out, ln)
}
scanFixed := bytes.Join(out, []byte{'\n'})
write(scanPath, scanFixed)

// 2) Hard-reset cmd/check/main.go to a minimal known-good checker that compiles.
checkPath := filepath.FromSlash("cmd/check/main.go")
check := []byte(package main

import (
"encoding/json"
"flag"
"fmt"
"os"
"strings"
)

type Direction string

type Trend struct {
DeltaScore   float64    + "json:\"deltaScore\"" + 
DeltaPercent float64    + "json:\"deltaPercent\"" + 
Direction    Direction  + "json:\"direction\"" + 
From         float64    + "json:\"from\"" + 
To           float64    + "json:\"to\"" + 
}

type Risk struct {
Score    float64  + "json:\"score\"" + 
Maturity string   + "json:\"maturity\"" + 
Posture  string   + "json:\"posture\"" + 
}

type Enriched struct {
SchemaVersion string     + "json:\"schemaVersion\"" + 
GeneratedUtc  string     + "json:\"generatedUtc\"" + 
Trend         *Trend     + "json:\"trend,omitempty\"" + 
Risk          Risk       + "json:\"risk\"" + 
LastN         []float64  + "json:\"lastN\"" + 
}

func postureRank(p string) int {
switch strings.ToUpper(strings.TrimSpace(p)) {
case "LOW":
return 0
case "MODERATE":
return 1
case "HIGH":
return 2
case "CRITICAL":
return 3
default:
return 99
}
}

func zeroSmall(v float64) float64 {
if v > -0.0000001 && v < 0.0000001 {
return 0
}
return v
}

func main() {
in := flag.String("in", "out/recovery-enriched.json", "Path to recovery-enriched.json")
maxRisk := flag.String("max-risk", "MODERATE", "Highest allowed risk posture: LOW|MODERATE|HIGH|CRITICAL")
maxDrop := flag.Float64("max-drop", 0, "Max allowed score drop vs previous run (points). 0 disables.")
maxDropPct := flag.Float64("max-drop-pct", 0, "Max allowed score drop vs previous run (percent). 0 disables.")
flag.Parse()

b, err := os.ReadFile(*in)
if err != nil {
fmt.Printf("CHECK FAIL: cannot read %s (%v)\n", *in, err)
os.Exit(2)
}

var en Enriched
if err := json.Unmarshal(b, &en); err != nil {
fmt.Printf("CHECK FAIL: invalid JSON in %s (%v)\n", *in, err)
os.Exit(2)
}

allowed := postureRank(*maxRisk)
actual := postureRank(en.Risk.Posture)

fail := false

if actual > allowed {
fmt.Printf("CHECK FAIL: risk posture %s exceeds allowed %s\n", strings.ToUpper(en.Risk.Posture), strings.ToUpper(*maxRisk))
fail = true
} else {
fmt.Printf("CHECK OK: risk posture %s within allowed %s\n", strings.ToUpper(en.Risk.Posture), strings.ToUpper(*maxRisk))
}

if en.Trend == nil {
fmt.Printf("CHECK NOTE: no trend available (first run or history missing)\n")
} else {
drop := zeroSmall(-en.Trend.DeltaScore)
dropPct := zeroSmall(-en.Trend.DeltaPercent)

if *maxDrop > 0 && drop > *maxDrop {
fmt.Printf("CHECK FAIL: regression %.2f points exceeds max-drop %.2f\n", drop, *maxDrop)
fail = true
} else if *maxDrop > 0 {
fmt.Printf("CHECK OK: regression %.2f points within max-drop %.2f\n", drop, *maxDrop)
}

if *maxDropPct > 0 && dropPct > *maxDropPct {
fmt.Printf("CHECK FAIL: regression %.2f%% exceeds max-drop-pct %.2f%%\n", dropPct, *maxDropPct)
fail = true
} else if *maxDropPct > 0 {
fmt.Printf("CHECK OK: regression %.2f%% within max-drop-pct %.2f%%\n", dropPct, *maxDropPct)
}
}

if fail {
os.Exit(1)
}

fmt.Printf("CHECK PASS: score=%.2f maturity=%s\n", en.Risk.Score, en.Risk.Maturity)
}
)
write(checkPath, check)

fmt.Println("Doctor complete.")
}

