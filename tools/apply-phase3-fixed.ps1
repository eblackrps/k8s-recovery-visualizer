Set-StrictMode -Version Latest
$ErrorActionPreference = "Stop"

function FailIfLastExit([string]$what) { if ($LASTEXITCODE -ne 0) { throw "$what failed with exit code $LASTEXITCODE" } }
function WriteUtf8NoBom([string]$path, [string[]]$lines) {
  $dir = Split-Path -Parent $path
  if ($dir -and !(Test-Path $dir)) { New-Item -ItemType Directory -Force -Path $dir | Out-Null }
  $utf8NoBom = New-Object System.Text.UTF8Encoding($false)
  [System.IO.File]::WriteAllText($path, (($lines -join "`n") + "`n"), $utf8NoBom)
  Write-Host "Wrote $path"
}

# Detect module path
if (!(Test-Path ".\go.mod")) { throw "go.mod not found" }
$modLine = (Get-Content .\go.mod | Select-String -Pattern '^module\s+').Line
if (!$modLine) { throw "Could not detect module path from go.mod" }
$modulePath = ($modLine -replace '^module\s+', '').Trim()
Write-Host "Module: $modulePath"

$bt = [char]96

# ---------------- internal/profile/profiles.go ----------------
WriteUtf8NoBom ".\internal\profile\profiles.go" @(
  "package profile",
  "",
  "import ""strings""",
  "",
  "type Name string",
  "",
  "const (",
  "    Standard   Name = ""standard""",
  "    Enterprise Name = ""enterprise""",
  "    Dev        Name = ""dev""",
  "    Airgap     Name = ""airgap""",
  ")",
  "",
  "func Normalize(s string) Name {",
  "    v := strings.ToLower(strings.TrimSpace(s))",
  "    switch v {",
  "    case ""enterprise"": return Enterprise",
  "    case ""dev"": return Dev",
  "    case ""airgap"": return Airgap",
  "    default: return Standard",
  "    }",
  "}",
  "",
  "func Weights(p Name) map[string]float64 {",
  "    switch p {",
  "    case Enterprise:",
  "        return map[string]float64{",
  "            ""restoreTesting"": 1.50,",
  "            ""immutability"":  1.30,",
  "            ""replication"":   1.20,",
  "            ""security"":      1.20,",
  "        }",
  "    case Dev:",
  "        return map[string]float64{",
  "            ""restoreTesting"": 1.10,",
  "            ""immutability"":  0.90,",
  "            ""replication"":   0.90,",
  "        }",
  "    case Airgap:",
  "        return map[string]float64{",
  "            ""immutability"":  1.60,",
  "            ""airgap"":        1.60,",
  "            ""security"":      1.30,",
  "            ""restoreTesting"": 1.20,",
  "        }",
  "    default:",
  "        return map[string]float64{}",
  "    }",
  "}"
)

# ---------------- internal/enrich/enrich.go ----------------
WriteUtf8NoBom ".\internal\enrich\enrich.go" @(
  "package enrich",
  "",
  "import (",
  "    ""encoding/json""",
  "    ""fmt""",
  "    ""os""",
  "    ""path/filepath""",
  "    ""strings""",
  "    ""time""",
  "",
  "    ""$modulePath/internal/profile""",
  "    ""$modulePath/internal/risk""",
  "    ""$modulePath/internal/trend""",
  ")",
  "",
  "const SchemaVersion = ""v1""",
  "",
  "type CategoryScore struct {",
  ("    Name     string  " + $bt + "json:""name""" + $bt),
  ("    Raw      float64 " + $bt + "json:""raw""" + $bt),
  ("    Weight   float64 " + $bt + "json:""weight""" + $bt),
  ("    Weighted float64 " + $bt + "json:""weighted""" + $bt),
  ("    Max      float64 " + $bt + "json:""max""" + $bt),
  ("    Grade    string  " + $bt + "json:""grade""" + $bt),
  "}",
  "",
  "type CategoryDelta struct {",
  ("    Name  string  " + $bt + "json:""name""" + $bt),
  ("    From  float64 " + $bt + "json:""from""" + $bt),
  ("    To    float64 " + $bt + "json:""to""" + $bt),
  ("    Delta float64 " + $bt + "json:""delta""" + $bt),
  "}",
  "",
  "type HistoryIndex struct {",
  ("    Entries []HistoryEntry " + $bt + "json:""entries""" + $bt),
  "}",
  "",
  "type HistoryEntry struct {",
  ("    TimestampUtc string  " + $bt + "json:""timestampUtc""" + $bt),
  ("    Overall      float64 " + $bt + "json:""overall""" + $bt),
  ("    Maturity     string  " + $bt + "json:""maturity""" + $bt),
  "}",
  "",
  "type Enriched struct {",
  ("    SchemaVersion string        " + $bt + "json:""schemaVersion""" + $bt),
  ("    GeneratedUtc  string        " + $bt + "json:""generatedUtc""" + $bt),
  ("    Profile       string        " + $bt + "json:""profile""" + $bt),
  ("    Current       HistoryEntry  " + $bt + "json:""current""" + $bt),
  ("    Previous      *HistoryEntry " + $bt + "json:""previous,omitempty""" + $bt),
  ("    Trend         *trend.Trend  " + $bt + "json:""trend,omitempty""" + $bt),
  ("    Risk          risk.Rating   " + $bt + "json:""risk""" + $bt),
  ("    LastN         []float64     " + $bt + "json:""lastN""" + $bt),
  "",
  ("    Categories         []CategoryScore " + $bt + "json:""categories,omitempty""" + $bt),
  ("    ProfileOverall     *float64        " + $bt + "json:""profileOverall,omitempty""" + $bt),
  ("    ProfileRiskPosture *string         " + $bt + "json:""profileRiskPosture,omitempty""" + $bt),
  ("    CategoryDeltas     []CategoryDelta " + $bt + "json:""categoryDeltas,omitempty""" + $bt),
  "}",
  "",
  "type Options struct {",
  "    OutDir     string",
  "    LastNCount int",
  "    Profile    string",
  "}",
  "",
  "type scanLike struct {",
  ("    Categories []CategoryScore " + $bt + "json:""categories""" + $bt),
  "}",
  "",
  "func Run(opts Options) (*Enriched, error) {",
  "    if opts.OutDir == """" { opts.OutDir = ""out"" }",
  "    if opts.LastNCount <= 0 { opts.LastNCount = 10 }",
  "",
  "    p := strings.TrimSpace(opts.Profile)",
  "    if p == """" { p = os.Getenv(""DR_PROFILE"") }",
  "    pn := profile.Normalize(p)",
  "",
  "    // overall history",
  "    historyPath := filepath.Join(opts.OutDir, ""history"", ""index.json"")",
  "    b, err := os.ReadFile(historyPath)",
  "    if err != nil {",
  "        return &Enriched{",
  "            SchemaVersion: SchemaVersion,",
  "            GeneratedUtc:  time.Now().UTC().Format(time.RFC3339),",
  "            Profile:       string(pn),",
  "            Risk:          risk.FromScore(0, """"),",
  "            LastN:         []float64{},",
  "        }, nil",
  "    }",
  "",
  "    var idx HistoryIndex",
  "    if err := json.Unmarshal(b, &idx); err != nil {",
  "        return nil, fmt.Errorf(""parse history index: %w"", err)",
  "    }",
  "    if len(idx.Entries) == 0 {",
  "        return &Enriched{",
  "            SchemaVersion: SchemaVersion,",
  "            GeneratedUtc:  time.Now().UTC().Format(time.RFC3339),",
  "            Profile:       string(pn),",
  "            Risk:          risk.FromScore(0, """"),",
  "            LastN:         []float64{},",
  "        }, nil",
  "    }",
  "",
  "    curr := idx.Entries[len(idx.Entries)-1]",
  "    var prev *HistoryEntry",
  "    if len(idx.Entries) >= 2 { p := idx.Entries[len(idx.Entries)-2]; prev = &p }",
  "",
  "    start := 0",
  "    if len(idx.Entries) > opts.LastNCount { start = len(idx.Entries) - opts.LastNCount }",
  "    last := make([]float64, 0, len(idx.Entries)-start)",
  "    for i := start; i < len(idx.Entries); i++ { last = append(last, idx.Entries[i].Overall) }",
  "",
  "    var tr *trend.Trend",
  "    if prev != nil { t := trend.Compute(prev.Overall, curr.Overall); tr = &t }",
  "",
  "    en := &Enriched{",
  "        SchemaVersion: SchemaVersion,",
  "        GeneratedUtc:  time.Now().UTC().Format(time.RFC3339),",
  "        Profile:       string(pn),",
  "        Current:       curr,",
  "        Previous:      prev,",
  "        Trend:         tr,",
  "        Risk:          risk.FromScore(curr.Overall, curr.Maturity),",
  "        LastN:         last,",
  "    }",
  "",
  "    // best-effort categories from recovery-scan.json",
  "    scanPath := filepath.Join(opts.OutDir, ""recovery-scan.json"")",
  "    if sb, err := os.ReadFile(scanPath); err == nil {",
  "        var sl scanLike",
  "        if json.Unmarshal(sb, &sl) == nil && len(sl.Categories) > 0 {",
  "            en.Categories = sl.Categories",
  "",
  "            if po, pr := computeProfileOverall(sl.Categories, profile.Weights(pn)); po != nil {",
  "                en.ProfileOverall = po",
  "                en.ProfileRiskPosture = pr",
  "            }",
  "            en.CategoryDeltas = computeCategoryDeltas(opts.OutDir, sl.Categories)",
  "        }",
  "    }",
  "",
  "    return en, nil",
  "}",
  "",
  "func computeProfileOverall(cats []CategoryScore, w map[string]float64) (*float64, *string) {",
  "    if len(w) == 0 { return nil, nil }",
  "    totalMax := 0.0",
  "    totalGot := 0.0",
  "    for _, c := range cats {",
  "        mul := 1.0",
  "        if v, ok := w[c.Name]; ok { mul = v }",
  "        totalMax += c.Max * mul",
  "        totalGot += c.Weighted * mul",
  "    }",
  "    if totalMax <= 0.00001 { return nil, nil }",
  "    score := (totalGot / totalMax) * 100.0",
  "    r := risk.FromScore(score, """")",
  "    p := string(r.Posture)",
  "    return &score, &p",
  "}",
  "",
  "type enrichIndex struct {",
  ("    Entries []enrichEntry " + $bt + "json:""entries""" + $bt),
  "}",
  "type enrichEntry struct {",
  ("    TimestampUtc  string          " + $bt + "json:""timestampUtc""" + $bt),
  ("    Path          string          " + $bt + "json:""path""" + $bt),
  ("    Categories    []CategoryScore " + $bt + "json:""categories""" + $bt),
  ("    SchemaVersion string          " + $bt + "json:""schemaVersion""" + $bt),
  ("    Profile       string          " + $bt + "json:""profile""" + $bt),
  "}",
  "",
  "func computeCategoryDeltas(outDir string, current []CategoryScore) []CategoryDelta {",
  "    idxPath := filepath.Join(outDir, ""history"", ""enriched-index.json"")",
  "    b, err := os.ReadFile(idxPath)",
  "    if err != nil { return []CategoryDelta{} }",
  "    var ix enrichIndex",
  "    if json.Unmarshal(b, &ix) != nil { return []CategoryDelta{} }",
  "    if len(ix.Entries) < 1 { return []CategoryDelta{} }",
  "",
  "    prevEntry := ix.Entries[len(ix.Entries)-1]",
  "    prevMap := map[string]CategoryScore{}",
  "    for _, c := range prevEntry.Categories { prevMap[c.Name] = c }",
  "",
  "    deltas := make([]CategoryDelta, 0, len(current))",
  "    for _, c := range current {",
  "        if p, ok := prevMap[c.Name]; ok {",
  "            d := c.Weighted - p.Weighted",
  "            deltas = append(deltas, CategoryDelta{Name: c.Name, From: p.Weighted, To: c.Weighted, Delta: d})",
  "        }",
  "    }",
  "    return deltas",
  "}"
)

# ---------------- internal/enrich/report.go ----------------
# IMPORTANT: No inline struct tags here. Snapshot is a map[string]any to avoid quoting hell.
WriteUtf8NoBom ".\internal\enrich\report.go" @(
  "package enrich",
  "",
  "import (",
  "    ""encoding/json""",
  "    ""fmt""",
  "    ""os""",
  "    ""path/filepath""",
  "    ""strings""",
  "    ""time""",
  ")",
  "",
  "func WriteArtifacts(outDir string, en *Enriched) error {",
  "    if outDir == """" { outDir = ""out"" }",
  "",
  "    jpath := filepath.Join(outDir, ""recovery-enriched.json"")",
  "    jb, _ := json.MarshalIndent(en, """", ""  "")",
  "    if err := os.WriteFile(jpath, jb, 0644); err != nil {",
  "        return fmt.Errorf(""write enriched json: %w"", err)",
  "    }",
  "",
  "    // Write enrich snapshot + index (for category deltas)",
  "    if err := writeEnrichHistory(outDir, en); err != nil {",
  "        fmt.Printf(""EnrichHistory: FAILED (%v)\n"", err)",
  "    }",
  "",
  "    // Markdown append",
  "    mdPath := filepath.Join(outDir, ""recovery-report.md"")",
  "    if b, err := os.ReadFile(mdPath); err == nil {",
  "        aug := string(b) + ""\n\n"" + renderMarkdown(en) + ""\n""",
  "        if err := os.WriteFile(mdPath, []byte(aug), 0644); err != nil {",
  "            return fmt.Errorf(""append md report: %w"", err)",
  "        }",
  "    }",
  "    return nil",
  "}",
  "",
  "func renderMarkdown(en *Enriched) string {",
  "    var sb strings.Builder",
  "    sb.WriteString(""## Trend, Risk, Profiles\n\n"")",
  "    sb.WriteString(fmt.Sprintf(""- **Schema:** %s\n"", en.SchemaVersion))",
  "    sb.WriteString(fmt.Sprintf(""- **Profile:** %s\n"", en.Profile))",
  "    sb.WriteString(fmt.Sprintf(""- **DR Risk Posture (base):** %s\n"", en.Risk.Posture))",
  "    if en.ProfileOverall != nil && en.ProfileRiskPosture != nil {",
  "        sb.WriteString(fmt.Sprintf(""- **Profile Score:** %0.2f\n"", *en.ProfileOverall))",
  "        sb.WriteString(fmt.Sprintf(""- **Profile Risk Posture:** %s\n"", *en.ProfileRiskPosture))",
  "    } else {",
  "        sb.WriteString(""- **Profile Score:** (not available)\n"")",
  "    }",
  "",
  "    if en.Trend == nil || en.Previous == nil {",
  "        sb.WriteString(""\n- **Trend:** FIRST RUN (no previous scan found)\n"")",
  "    } else {",
  "        arrow := ""→""",
  "        switch en.Trend.Direction {",
  "        case ""up"": arrow = ""↑""",
  "        case ""down"": arrow = ""↓""",
  "        }",
  "        sb.WriteString(fmt.Sprintf(""\n- **Trend:** %s %+0.2f (%+0.2f%%)\n"", arrow, en.Trend.DeltaScore, en.Trend.DeltaPercent))",
  "    }",
  "",
  "    if len(en.Categories) > 0 {",
  "        sb.WriteString(""\n### Categories\n"")",
  "        for _, c := range en.Categories {",
  "            sb.WriteString(fmt.Sprintf(""- %s: %0.2f / %0.2f (w=%0.2f)\n"", c.Name, c.Weighted, c.Max, c.Weight))",
  "        }",
  "    }",
  "",
  "    if len(en.CategoryDeltas) > 0 {",
  "        sb.WriteString(""\n### Category Deltas (vs last enrich snapshot)\n"")",
  "        for _, d := range en.CategoryDeltas {",
  "            sb.WriteString(fmt.Sprintf(""- %s: %0.2f → %0.2f (Δ %+0.2f)\n"", d.Name, d.From, d.To, d.Delta))",
  "        }",
  "    }",
  "",
  "    return sb.String()",
  "}",
  "",
  "func writeEnrichHistory(outDir string, en *Enriched) error {",
  "    if len(en.Categories) == 0 { return nil }",
  "",
  "    histDir := filepath.Join(outDir, ""history"", ""enriched"")",
  "    if err := os.MkdirAll(histDir, 0755); err != nil { return err }",
  "",
  "    ts := time.Now().UTC().Format(""20060102T150405Z"")",
  "    snapName := fmt.Sprintf(""%s.json"", ts)",
  "    snapPath := filepath.Join(histDir, snapName)",
  "",
  "    snap := map[string]any{",
  "        ""timestampUtc"":  ts,",
  "        ""schemaVersion"": en.SchemaVersion,",
  "        ""profile"":       en.Profile,",
  "        ""categories"":    en.Categories,",
  "    }",
  "",
  "    jb, _ := json.MarshalIndent(snap, """", ""  "")",
  "    if err := os.WriteFile(snapPath, jb, 0644); err != nil { return err }",
  "",
  "    idxPath := filepath.Join(outDir, ""history"", ""enriched-index.json"")",
  "    var ix enrichIndex",
  "    if b, err := os.ReadFile(idxPath); err == nil { _ = json.Unmarshal(b, &ix) }",
  "",
  "    ix.Entries = append(ix.Entries, enrichEntry{",
  "        TimestampUtc:  ts,",
  "        Path:          filepath.ToSlash(filepath.Join(""history"", ""enriched"", snapName)),",
  "        Categories:    en.Categories,",
  "        SchemaVersion: en.SchemaVersion,",
  "        Profile:       en.Profile,",
  "    })",
  "",
  "    ib, _ := json.MarshalIndent(ix, """", ""  "")",
  "    return os.WriteFile(idxPath, ib, 0644)",
  "}"
)

Write-Host "Running gofmt..."
gofmt -w .\cmd .\internal | Out-Null
FailIfLastExit "gofmt"

Write-Host "Building scan.exe..."
if (Test-Path .\scan.exe) { Remove-Item .\scan.exe -Force }
go build -o scan.exe .\cmd\scan
FailIfLastExit "go build (scan.exe)"

Write-Host "Building check.exe..."
go build -o check.exe .\cmd\check
FailIfLastExit "go build (check.exe)"

Write-Host "Phase 3 applied (fixed)."
